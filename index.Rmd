---
title: "R mini course TEST2"
author: "Nicole Kinlock"
date: June 11, 2025
output:
  revealjs::revealjs_presentation:
    theme: simple
    highlight: haddock
    transition: fade
    self_contained: false
    reveal_plugins: ["menu"]
    reveal_options:
        controls: true
        slideNumber: true
        margin: 0.02
---

# Overview

```{css, echo = FALSE}
:root {
    --r-main-font-size: 36px;
}
```

```{r, echo = FALSE}
library(knitr)
opts_knit$set(global.par = TRUE)
```

- Part 1: <a href = "#/3"> Basics of R </a>
- Part 2: <a href = "#/44"> Probability & distributions </a>
- Part 3: <a href = "#/62"> Data manipulation </a>
- Part 4: <a href = "#/98"> Looping and vectorization </a>
- Part 5: <a href = "#/136"> Functions </a>
- Part 6: <a href = "#/149"> Data visualization using ggplot2 </a>


## About this course

This course was originally developed by Ben Weinstein (2014), Mike McCann (2015), and Nicole Kinlock (2016, 2017) as a workshop in the Department of Ecology & Evolution at Stony Brook University


# **Part 1:** Basics of R


## What is R?

- Statistical programming language and environment
- Freely available as public domain software *(i.e. not copyrighted)*
- Available on all operating systems: Windows, macOS, Linux
- Better than most commercial alternatives
- Not just for statistics, but also general purpose programming


## Why use R?

- Flexible
- Transparent
- Large user base
- Valued skill


## RStudio

- Integrated development environment (IDE) for the R language
- Specifically designed to improve coding experience in R
- Free version available
- When you open RStudio, it should find your locally installed version of R


## RStudio layout

- The screen is split four ways: 
  - **Workspace:** (Top left) Write scripts are written & saved
  - **Console:** (Bottom left) Where commands are run
  - **Environment, History:** (Top right) Where objects are stored
  - **Files, Plots, Packages, & Help:** (Bottom right) View filesystem, figures, packages, help
      

## Writing a script

- A **script** is a plain text file with R commands in it -- this will be where you save the code that you are writing
- The file will end in the extension `.R`
- Open a new script by clicking the `New file` icon in the top left corner of RStudio and selecting `R script`
    

## Run R code

- Type directly into the console (best when you don't want to save the code) or type into a script (can be saved and rerun as needed)
- In the console: run code by hitting the `ENTER` key (`⏎`)
- In a script: run code by placing your cursor on a line (or highlight a larger block of code) and hitting the `CTRL + ENTER` (`STRG + ⏎`) keys on Windows/Linux or `CMD + ENTER` (`CMD + ⏎`) on Mac
- Note that you *could* also use the `Run` button in RStudio -- however, I recommend relying on the GUI as little as possible when you're learning to code


## R as a calculator 

- R has many **arithmetic** operators 
  - `+`  Addition 
  - `-`  Subtraction 
  - `*`  Multiplication 
  - `/`  Division 
  - `^`  Exponentiation 
  - `%%` Modulus (finds remainder) 
  - `%/%` Integer division (leaves off remainder)

- R obeys the standard order of operations


## R as a calculator

```{r}
1105 / 4
3^2
10 %% 7
```


## R is logical 

- R also has many **logical** operators 
  - `<`  Less than
  - `<=` Less than or equal to 
  - `>`  Greater than
  - `>=` Greater than or equal to  
  - `==` Exactly equal to 
  - `!=` Not equal to 
  - `!`  NOT
  - `|`  OR
  - `&`  AND


## R is logical 

```{r}
7 == 4
3 > 2
3 < 2 & 7 != 4
```


## Your turn {data-background-color=#b3cde3}

1. What is 45 multiplied by 982?

2. What is 13 to the fifth power?

3. Is 8 to the third power equal to the sum of 52 and 76 multiplied by 4?


## Creating objects

- An **object** is the fundamental unit in R -- all expressions can be saved as an object
- Objects show up in your environment (upper right panel)
- To create an object we use the **assignment operator** (`<-`), which assigns expressions on the right to objects on the left

```{r}
a <- (14 + 185)^2
a
```


## Assignment operator

- Do not use `=` for assignment in R. It's best practice to use `<-` instead.
- This is arbitrary, but a convention in R
    - FYI: the reasoning is that `<-` maintains backwards compatibility with S-Plus
- But, it can be a good idea to follow conventions -- this makes your code more readable to others
    - <a href = "https://google.github.io/styleguide/Rguide.html" target = "_blank">Google's R Style Guide</a>
    - <a href = "http://adv-r.had.co.nz/Style.html" target = "_blank">Advanced R: Style Guide</a>


## R Tip: Comment on your code {data-background-color=#ccebc5}

- Use hashtags (`#`) to comment on your script -- anything to the right of a `#` is ignored
- It's surprisingly hard to remember what you did when reviewing older code, and it's particularly important when other people are reading your code  

```{r}
5 + 5  # this adds five and five 
# 10 + 10 this does not add ten and ten
```


## Expressions using objects

Objects can be combined into other, larger objects

```{r}
a <- 8 * 5
b <- 2 * 10
d <- a * b
d
# this is equivalent to: 
d <- 8 * 5 * 2 * 10
d
```


## Your turn {data-background-color=#b3cde3}

1. Create an object that is equal to your age. Create another object that is equal to the age of the person next to you. Find the difference between these objects. 


## Data structure 1: Vectors

- R has 5 common data structures -- we will start with the simplest: **vectors**, which are one dimensional structures
- Vectors come in four types: numeric, integer, logical (`TRUE` or `FALSE`), and character
- A vector is made using the combine function, `c()`.


## Vectors with integers and numbers

```{r}
b <- c(3.24, 4.57, 5.03)
b
z <- c(8, 4, 2, 1, 1)
z
```


## Vectors with characters

Characters in R need to be enclosed in quotation marks

```{r}
pets <- c("dog", "cat", "bird", "fish")
pets
```


## Vectors - Combining multiple objects

```{r}
# make objects 
a <- sqrt(4 * 7)
b <- c(2, 5)
g <- 19 / 2
# combine
d <- c(a, b, g)
d
```


## Vectors - Regular sequences

You can use a colon (**:**) to create a vector that includes all integers in between the numbers on either side of the colon

```{r}
x <- 1:10
x
```


## Vectors - Regular sequences

You can use the `seq()` function to create a sequential vector with a particular minimum (`from`), maximum (`to`), and increment (`by`)

```{r}
x <- seq(from = 0, to = 20, by = 2)
x
```


## Your turn {data-background-color=#b3cde3}

1. Create a vector that includes all integers between 5 and 25. Name this vector `x`.

2. Create a vector that includes all even integers between 2 and 22. Name this vector `y`.

3. Create a single vector that **combines** object x and object y. Name this vector `z`.


## Vectors - Index by position

You can access any element in a vector by putting its **position** in square brackets `[]`

```{r}
height <- c(76, 72, 74, 74, 78)
height
height[5]  # extract the 5th element in the vector 
```


## Vectors - Index by position

You can also use positional vector indexing to return the same vector, but with certain elements missing, using the minus (`-`) sign

```{r}
height <- c(76, 72, 74, 74, 78)
height[-1]
height[-c(2, 4)]
```


## Vectors - Index by name

You can assign **names** to each element of the vector, and then extract an element by indexing based on the name

```{r}
temp <- c(monday = 28.1, tuesday = 28.5, wednesday = 29.0, 
          thursday = 30.1, friday = 30.2)
temp
temp["wednesday"]
temp[3]
```


## Vectors - Logical indexing

You can extract elements in a vector that meet specific criteria based on a **logical expression**

```{r}
y <- 5:50
y[y <= 10]   # extract elements less than or equal to 10
y[y < 10 & y != 5]   # extract elements less than 10 that are not equal to 5
```


## Your turn {data-background-color=#b3cde3}

1. What are the 5th and 12th positions of the vector `seq(from = 5, to = 15, by = 0.5)`? 

2. Create the vector `15:45` and name it `m`. Extract all elements of `m` that are greater than or equal to 21.


## What is a function?

- A function is an object that performs a task given some inputs called **arguments**
- R has many functions already available, but you can also write your own
- Functions are called in the format: `FunctionName(arguments)`
- The output of a function can be saved as an object: `output <- FunctionName(arguments)`


## Function arguments

- It's not necessary to name arguments, but it can be helpful for you and others reading your code
- If you don't name arguments, then the order in which you enter them matters

```{r}
seq(1, 10, 1)
seq(from = 1, to = 10, by = 1)
```


## Common functions

- Use `sum()` to take the sum of all elements in a vector:

```{r}
sum(c(3, 4, 5))
```

- Use `mean()` to take the mean of all elements in a vector:

```{r}
mean(seq(5, 100, 5))
```


## Functions can act on an object

```{r}
x <- seq(5, 100, 5)
# use the vector x as the input to the mean function
mean(x)
```


## R Tip: The help system {data-background-color=#ccebc5}

Help files provide information on what a function does and list examples at the bottom

```{r}
help(mean)
?mean  # same as help(mean) 
??robust  # search for help files containing "robust"
```


## Your turn {data-background-color=#b3cde3}

1. What is the median of 26, 24, 8, 17, and 42?   
*Hint:* functions are often named intuitively

2. What does the function `range()` do? Take the range of a vector `c(10, 8, 3, 5)`

3. Is `mean(4, 5)` different than `mean(c(4, 5))`?


## Packages

- Functions can be kept inside **packages**
- Some packages come pre-installed with R, and others must be downloaded


## Packages

- There are many, many R packages - currently 22,477 (when I first taught this course in 2016, there were "only" 7,742)
- You can view all packages here: <a href = "http://cran.r-project.org/web/packages/available_packages_by_name.html" target = "_blank"> List of R Packages</a>
- There are lots of packages commonly used by ecologists and evolutionary biologists (e.g., `ape`, `sf`, `lme4`, `dplyr`)


## Installing packages

- To install a package use the `install.packages()` function
- Be sure to surround the package name in quotation marks (`""`)

```{r, eval = FALSE}
install.packages("ggplot2") 
```


## Loading packages

- You have to **load** packages using the `library()` or `require()` functions in order to use them every time you restart R
- This lets R know which packages to load and not waste memory by loading all possible functions

```{r}
library(ggplot2)  # no quotation marks needed
require(ggplot2)
```

```{r, include = FALSE}
theme_set(theme(plot.margin = unit(c(0, 0, 0, 0), "mm"), plot.background = element_blank(), text = element_text(size = 16)))
```


## R Tip: Loading packages {data-background-color=#ccebc5}

- Good scripts have a series of `require()` or `library()` statements at the **top** of the script.

- FYI: <a href = "http://yihui.name/en/2014/07/library-vs-require/">Some say</a> that you should preferentially use `library()`, because `require()` "tries" to load a package and `library()` actually loads a package
    - If you use `require()` at the top of the screen and you don't have the package installed, you'll get an error message later on when you use functions in the package (whereas with `library()` you'll get an error right away)


## The R user community

<a href = "http://stackoverflow.com/questions/tagged/r" target = "_blank">Stack Overflow</a> 

<a href = "http://www.r-bloggers.com/" target = "_blank">R-Bloggers</a> 

<a href = "http://www.r-project.org/mail.html" target = "_blank">R Mailing Lists</a>

Note that large language model chatbots like ChatGPT were trained using the above sources


## Useful link

<a href = "https://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/plotmath.html" target = "_blank">Mathematical Annotation in R</a>


## Practice {data-background-color=#fbb4ae}

Worksheets created by Mike McCann and hosted on his Rpubs site

<a href = "https://rpubs.com/mccannecology/53351" target = "_blank">Worksheet</a>

<a href = "https://rpubs.com/mccannecology/53358" target = "_blank">Answers</a>


# **Part 2:** Probability & distributions


## Review {data-background-color=#decbe4}

1. What is the sum of 1 through 10, multiplied by two? 

2. What are the 12th and 45th positions of the vector `seq(1, 43, 0.25)`?

3. Find all of the elements of the vector `seq(1, 10, 0.1)` that are less than 2. What is the median value of these elements?


## Statistical distributions

To sample 1000 times from a normal probability distribution with mean 0 and standard deviation 1, we can use the `rnorm()` function

```{r}
norm <- rnorm(n = 1000, mean = 0, sd = 1)
head(norm)
```

```{r, echo = FALSE, fig.height = 2, fig.width = 3}
par(mfrow = c(1, 1), mar = c(2.5, 2.5, 0, 0), mgp = c(1.5, 0.6, 0), cex.main = 1.1, cex.axis = 1.1, cex.lab = 1.1)
hist(norm, col = "palevioletred", main = "", xlab = "", ylab = "Frequency")
```


## Your turn {data-background-color=#b3cde3}

1. Sample 100 random numbers from a normal distribution with a mean of 3 and a standard deviation of 2, and assign it to an object `a`.

2. Find the mean of your sample. How close was it to the true mean (the mean that you set in `rnorm()`)?

3. What is the 13th element in your vector `a`?


## Generating random samples from other distributions

- R has many available distributions, including all of those commonly used in biological analyses
- Depending on the distribution, each function has its own set of parameter arguments
- For example, the `rpois()` function is the random sampler for the Poisson distribution and it has only one parameter, `lambda` ($\lambda$).


## Your turn {data-background-color=#b3cde3}

1. Draw 100 random samples from a Poisson distribution with `lambda = 3`, and assign it to an object `x`.

2. Draw 1000 random samples from a Poisson distribution with `lambda = 3`, and assign it to an object `y`.

3. Calculate the means of both vectors. What is the difference between the means?


## Other properties of distributions 

- For each distribution, there are 4 functions that generate fundamental quantities
  - **`rnorm()`** random sample
  - **`dnorm()`** probability density function
  - **`pnorm()`** cumulative distribution function
  - **`qnorm()`** quantile function

```{r, echo = FALSE, fig.height = 3, fig.width = 6}
library(scales)
samp.size <- 1000
sn.quant <- seq(-4, 4, 0.01)
sn.yvals <- dnorm(x = sn.quant)
sn.samp20 <- rnorm(n = 20)
sn.xvals2 <- c(seq(-4, 2, 0.01), 2)
sn.yvals2 <- dnorm(x = sn.xvals2)
sn.yvals2[length(sn.yvals2)] <- 0
sn.d2 <- dnorm(x = 2)
sn.quant2 <- qnorm(p = 0.977)
plot(x = sn.quant, y = sn.yvals, type = "n", xlim = c(-4, 4), ylim = c(0, 0.4), xlab = "x", ylab = "dnorm(x)", bty = "n")
lines(x = sn.quant, y = sn.yvals, type = "l", lwd = 2, col = "#000000")
polygon(x = sn.xvals2, y = sn.yvals2, col = alpha("#E7AD52", 0.5), border = NA)
lines(x = c(2, 2), y = c(0, sn.d2), lwd = 2, col = "#51A1E8")
points(x = sn.samp20, y = rnorm(n = 20, mean = 0, sd = 0.005), cex = 1, pch = 19, col = "#E851CF")
points(x = sn.quant2, y = 0, cex = 1, pch = 19, col = "#74E851")
text(x = -2.3, y = 0.37, labels = "Y ~ Normal(μ = 0, σ = 1)", col = "#000000", cex = 1.2)
text(x = 1.8, y = 0.3, labels = "pnorm(q = 2)\n= 0.977", col = "#E7AD52", cex = 0.9)
text(x = -0.5, y = 0.03, labels = "rnorm(n = 20)", col = "#E851CF", cex = 0.9)
text(x = sn.quant2 + 0.5, y = 0.1, labels = "dnorm(x = 2)\n= 0.054", col = "#51A1E8", cex = 0.9)
text(x = sn.quant2 + 1.1, y = 0.04, labels = "qnorm(p = 0.977)\n= 2", col = "#74E851", cex = 0.9)
arrows(x0 = 1.5, y0 = 0.3, x1 = 0, y1 = 0.25, col = "#E7AD52", lwd = 1, length = 0.1)
arrows(x0 = 2.2, y0 = 0.08, x1 = 2, y1 = sn.d2, col = "#51A1E8", lwd = 1, length = 0.1)
arrows(x0 = 2.8, y0 = 0.04, x1 = 2, y1 = 0, col = "#74E851", lwd = 1, length = 0.1)
```

<small>Figure adapted from <a href = "http://user.mendelu.cz/drapela/Forest_Biometry/Lecture%20notes/R%20-%20tutorials%20and%20commands/R%20Probability%20Functions.pdf" target = _blank">this</a> website</small>


##  Plot distributions with histograms

- Histograms (`hist()`) place data into "bins", and count the number (frequency) of data falling into each bin

```{r, fig.height = 3, fig.width = 5}
sample <- rnorm(1000)
hist(sample, col = "palevioletred", main = "", xlab = "Value", 
     ylab = "Frequency")
```

- For those who care about color selection: <a href = "http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf" target = "_blank">R Colors</a>


## Your turn {data-background-color=#b3cde3}

1. Sample 10 random variates (values) from a normal distribution and make a histogram of the sample. Repeat for 100, then 1000 random variates. What do you notice about the histograms?

2. Take a random sample from a gamma distribution using the `rgamma()` function with `shape = 1` and make a histogram of the sample.


## Sampling

Take a random sample of elements in a vector using the `sample()` function

```{r}
x <- 1:50
sample(x, size = 20)  # sample without replacement
sample(x, size = 20, replace = TRUE)  # sample with replacement
```


## Your turn {data-background-color=#b3cde3}

1. Sample 15 elements from a vector of integers between 125 and 325 without replacement.

2. Sample 10 letters (using the pre-installed vector `letters`) with replacement.

3. Sample 0 or 1 twelve times, with and without replacement. What happens?


## Scatterplots

Scatterplots show the relationship between two variables (`plot(x, y)`)
 
```{r, fig.height = 3, fig.width = 3}
# random sample from a normal dist
sample1 <- rnorm(n = 40, mean = 4, sd = 2)
# random sample from a different normal dist
sample2 <- rnorm(n = 40, mean = 2, sd = 1)
plot(x = sample1, y = sample2, xlab = "Sample 1", ylab = "Sample 2")
```


## Add line to scatterplot

- Add straight lines to a plot using the `abline()` function
- Argument `a` specifies the intercept and `b` the slope

```{r, fig.height = 3, fig.width = 3}
plot(sample1, sample2, xlab = "Sample 1", ylab = "Sample 2")
abline(a = 0.5, b = 0.75, lwd = 2, col = "royalblue")
```


## Add model fit line to scatterplot

Lines can also be model fits -- `lm()` fits a linear model of **y** (`sample2`) as a function of **x** (`sample1`)

```{r, fig.height = 3, fig.width = 3}
plot(sample1, sample2, xlab = "Sample 1", ylab = "Sample 2")
abline(lm(sample2 ~ sample1), lwd = 2, col = "royalblue")
```


## Lots of useful links for plotting 

<a href = "http://rpubs.com/SusanEJohnston/7953" target = "_blank">R Base Graphics: An Idiot's Guide</a>

<a href = "https://leemendelowitz.github.io/blog/r-base-graphics-plotting.html" target = "_blank">R Base Graphics Plotting</a>

<a href = "http://www.harding.edu/fmccown/r/" target = "_blank">Producing Simple Graphs with R</a>

<a href = "http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf" target = "_blank">R Colors</a>

We will talk more about plotting in Part 6


## Practice {data-background-color=#fbb4ae}

<a href = "https://rpubs.com/mccannecology/53352" target = "_blank">Worksheet</a>

<a href = "https://rpubs.com/mccannecology/53359" target = "_blank">Answers</a>


# **Part 3:** Data manipulation


## Download the file for this section

<a href = "https://www.dropbox.com/s/qk11hhsipddk3fk/seedlings.csv?dl=0" target = "_blank">seedlings.csv</a>


## Data structure 2: Data frames

- Most data we work with in ecology & evolution is two-dimensional, including rows and columns
- **Data frames** are thus a very important data type in R

```{r}
# data frame with measurements of black cherry trees
head(trees)
```


## Iris data frame

- Data frames are usually read in from a file, but R also comes with practice data frames
- We will use the `iris` dataset, <a href = "http://en.wikipedia.org/wiki/Iris_flower_data_set" target = "_blank">famously used by R.A. Fisher in 1936</a>

```{r}
head(iris)
```


## Data frames - Useful functions

- `head()` - first six rows
- `tail()` - last six rows
- `dim()` - dimensions (# rows, # columns)
- `nrow()` - number of rows
- `ncol()` - number of columns
- `str()` - structure of object *(very useful!)*
- `class()` - class of object
- `rownames()` - row names 
- `colnames()` - column names


## Your turn {data-background-color=#b3cde3}

1. How many rows does the `iris` data frame have?

2. How many columns? What are the column names?

3. How many species are included in the dataset (use the `str()` function)?

4. What are the classes of each of the columns?


## Data structure 3: Factors

- In the `iris` data frame, species are encoded as a **factor**
- Factors, like vectors, are one dimensional and they describe categorical data, ordered by levels

```{r}
str(iris$Species)
levels(iris$Species)
```


## Convert vector to factor

- Make a vector into a factor using the `factor()` function
- Provide levels using the `levels` argument as a vector in your desired order

```{r}
exp.df <- data.frame(Individual = 1:4, Treatment = c("D", "C", "D", "C"))
str(exp.df$Treatment)
exp.df$Treatment <- factor(x = exp.df$Treatment, levels = c("D", "C"))
str(exp.df$Treatment)
```


## Data frames - Subsetting

- R has many powerful subset operators that will allow you to easily perform complex operations on any kind of dataset (much easier than with Excel!)
- Think of data frames as a series of vectors grouped together into a table

```{r}
head(iris)
```


## Data frames - Index by position

Index individual elements of a data frame with square brackets `df[row#, column#]`

```{r}
iris[1, 1]  # first row, first column
iris[3, 4]  # third row, fourth column
```


## Data frames - Index by position

Index entire rows or columns by leaving one of the positions blank: `df[, column#]` or `df[row#, ]`

```{r}
iris[2, ]  # subset the entire second row 
iris[, 2]  # subset the entire second column 
```


## Data frames - Index by position

- Data frames can be indexed for both rows and columns
- To get the 5th, 7th, and 9th rows for the first two columns in the `iris` data frame:

```{r}
iris[c(5, 7, 9), 1:2]
```


## Data frames - Index by name

- Columns can also be called by name using brackets

```{r, eval = FALSE}
iris[, "Sepal.Length"]
```

- Or you can call a column by name using dollar sign (`$`) notation

```{r, eval = FALSE}
iris$Sepal.Length
```


## Your turn {data-background-color=#b3cde3}

Using the `iris` dataframe...

1. Subset the 9th element of the `Sepal.Width` column

3. Subset the 1st, 4th, and 7th rows

4. Use the `seq()` function to subset all odd rows

5. What happens when you use negative numbers to index the `iris` dataframe? *Hint:* Use the function `dim()` on the original and final objects


## Data frames - Logical indexing

To subset the `iris` data frame to petal widths greater than 1 cm:

```{r}
iris.p1.sub <- iris[iris$Petal.Width > 1  , ]  
head(iris.p1.sub)
```


## Data frames - Logical indexing

We can compare the distributions of petal widths for the complete dataset and the subset:

```{r, echo = FALSE, fig.height = 3.5, fig.width = 6.5}
par(mfrow = c(1, 2))
hist(iris$Petal.Width, col = "darkseagreen1", xlab = "Petal width (in cm)", 
     ylab = "Frequency", main = NULL)
hist(iris.p1.sub$Petal.Width, col = "darkseagreen1", xlab = "Petal width (in cm)", 
     ylab = "Frequency", main = NULL)
par(mfrow = c(1, 1))
```


## Your turn {data-background-color=#b3cde3}

1. Why is `iris[iris > 3, ]` a nonsensical command?

2. Why is `iris[iris$Sepal.Length > 3]` a nonsensical command?

3. Create a histogram of petal lengths for the entire data.

4. Subset the data for petal lengths greater than two centimeters. Create a histogram of your new data.


## Data frames - Logical indexing

For all types of data, if we want to subset a specific value we use the logical operator "`==`"

```{r}
# subset of observations where petal length is equal to 4 cm
iris.p4.sub <- iris[iris$Petal.Length == 4.0,]
head(iris.p4.sub)
```


## Data frames - Logical indexing

Quotation marks (`""`) needed when subsetting by characters or factors

```{r}
# subset only records from the species Iris versicolor
iris.vers.sub <- iris[iris$Species == "versicolor", ]
head(iris.vers.sub)
```


## Data frames - Logical indexing

- It's also possible to combine logical statements:
  - Use **`&`** (AND) if *both* statements should be true
  - Use **`|`** (OR) if *either* statement should be true

```{r}
# subset species = versicolor AND petal length greater than 4 cm
iris.sub <- iris[iris$Petal.Length > 4 & iris$Species == "versicolor", ]
head(iris.sub)
```


## Your turn {data-background-color=#b3cde3}

Explain each of the following indexing statements:

1. `iris[1:4, ]`

2. `iris[c(1:15), c(1, 3)]`

3. `iris[iris$Species == "setosa", "Petal.Width"]`

4. What happens when you add a `!` before a logical statement? *Hint:* Compare `iris[iris$Species == "setosa", ]` and `iris[!(iris$Species == "setosa"), ]`.


## Data frames - Building from scratch

Use the **`data.frame()`** function

```{r}
num.df <- data.frame(x = 1:5, y = 6:2)
num.df
```


## Data frames - Add columns

You can also add columns using the `data.frame()` function

```{r}
num.df <- data.frame(num.df, z = letters[1:5])
num.df
```


## Data frames - Add columns

Or, you can use the assignment operator `<-` with the `$` notation

```{r}
num.df$z <- letters[1:5]
num.df
```


## Data frames - Remove columns

Use the minus (`-`) sign and the position you want to remove

```{r}
num.sub <- num.df[, -3]
num.sub
```


## Data frames - Remove columns

Or, assign `NULL` to the column

```{r}
num.df$z <- NULL
num.df
```


## Data structure 4: Matrices

- Similar to data frames, matrices are two-dimensional
- Unlike a data frame, however, a matrix can include only numbers (not characters or factors)

```{r}
num.mat <- matrix(1:9, ncol = 3, nrow = 3)
num.mat
```


## Matrices

Why do you need them? Some functions (e.g., matrix algebra functions) require a matrix as an input

```{r error = TRUE}
num.df <- as.data.frame(num.mat)  # convert matrix to df
diag(num.df)  # function fails with df
diag(num.mat)  # works with matrix
```


## Matrix indexing

Indexing is the same as with data frames

```{r}
num.mat[2, ]
num.mat[c(2, 3), 2]
```


## Importing your own data

- R is not a spreadsheet program, so it's not great for direct data entry
- It's best to start with spreadsheets for data entry and storage, and to import spreadsheets into R for data analysis and visualization
- CSV (comma separated values) files are often the preferred format for importing into R
- Before we import the example CSV file, we will need to consider **working directories**


## Working directory

- Find out what your current working directory is using the `getwd()` function
- This is the folder on your computer where R will look to open or write files
- Though you could also use the `Files` tab (bottom right panel) in RStudio, again I recommend relying on the GUI as little as possible

```{r}
getwd()
```


## Working directory

Set your working directory using the `setwd()` function

```{r, eval = FALSE}
setwd("/home/nlkinlock/Documents/")
```


## Importing data

- Load the `seedlings.csv` file (available on Ilias) using the `read.csv()` function
- If you include the full path to your file, you do not need to set your working directory

```{r, eval = FALSE}
seedling.df <- read.csv(file = "/home/nlkinlock/Documents/seedlings.csv", 
                        fileEncoding = "UTF-8")
```


## Importing data - file encoding

- File encoding can be a real pain with R -- special characters can render incorrectly (e.g., as "Ã", �, or question marks)
- Try to save spreadsheets with UTF-8 encoding and always include the `fileEncoding = "UTF-8"` argument when reading or writing files

```{r, eval = FALSE}
seedling.df <- read.csv(file = "/home/nlkinlock/Documents/seedlings.csv", 
                        fileEncoding = "UTF-8")
```


## R Tip: Variable names {data-background-color=#ccebc5}

- One of the largest sources of frustration with R can be importing data
- Variable names, e.g., column names, often cause problems
  - Do not include spaces or special characters in variable names
  - Abbreviate variable names when appropriate


## Your turn {data-background-color=#b3cde3}

1. Load the data frame `seedlings.csv` using the `read.csv()` function, and store it as an object called `seedlings.df`.

2. What is the mean height for all seedlings? What about the mean height for all seedlings except *Rhus typhina*?

3. What is the difference in the mean aboveground biomass for *Rosa multiflora* seedlings and *Rubus occidentalis* seedlings?


## Exporting data frames 

- After you've made changes or conducted an analyses, you may want to export your data frame
- Use the `write.csv()` function to export data frames
- Remember the `fileEncoding = "UTF-8"` argument

```{r, eval = FALSE}
# write the iris data frame to file 
write.csv(iris, file = "iris.csv", row.names = FALSE,
          fileEncoding = "UTF-8")
```


## Helpful link

<a href = "http://adv-r.had.co.nz/Data-structures.html" target = "_blank">Data structures</a>


## Practice {data-background-color=#fbb4ae}

<a href = "https://rpubs.com/mccannecology/53354" target = "_blank">Worksheet</a>

<a href = "https://rpubs.com/mccannecology/53360" target = "_blank">Answers</a>


# **Part 4:** Looping and vectorization


## For-loops

- Loops are an important tool across programming languages 
- For-loops run for a certain number of steps (iterations), and at each step, the statements in the loop are executed
- The basic syntax is:

`for (i in 1:number_iterations) {`

`   execute these statements`

`}`


## Why use a for-loop?

- For-loops are useful when we have a repeated process with identical steps, but different values
- Using loops can help you avoid writing repetitive code


## Our first for-loop (pseudocode)

`for (i in 1:5) {`

`i` starts at 1. R executes some statements; 

`i` is increased to `2` and statements are executed again; 

`i` is increased to `3` and statements are executed again; 

and so on, until `i = 5`, at which point the loop executes the set of statements for the last time

`}`


## Our first for-loop

```{r}
for (i in 1:5) {
    print(i)
}
```


## For-loops - braces vs. brackets 

- We'll now go through the differences among:
    - square brackets `[]`
    - curly braces `{}`: encases multiple statements within a control-flow construct (`for`, `while`, `if`, etc.) 
    - parentheses `()`: arithmetic use as well as 


## For-loops - Square brackets 

- Square brackets `[]` are used to **index** objects, i.e., to access elements of a vector, matrix, or data frame
- Pay attention to the number of dimensions the object has -- the number of *commas* inside `[]` indicates the number of dimensions

```{r}
test.vec <- seq(0.1, 10, 0.1)  # vector
test.vec[c(2, 6, 9)]  # 1 dimension, no commas
```


## For-loops - Square brackets 

```{r}
test.mat <- matrix(data = seq(0.1, 10, 0.1), nrow = 10, ncol = 10)  # matrix
test.mat[6, 6]  # 2 dimensions, 1 comma
test.mat[6, ]
```


## For-loops - Parentheses 

- Parentheses `()` ("round brackets" in British English) are used to call *functions*
- Arguments are placed inside the parentheses
- Note they are also used for arithmetic 

```{r}
x <- 1:10
sum(x)  # parentheses call sum() function
(1 + 2) * 3  # parentheses for arithmetic
```


## For loops - Curly braces 

Curly braces `{}` are used to enclose all of the statements to be executed in a for-loop (or another control flow statement, e.g., `if`, `while`, etc.)

```{r}
for (i in 1:3) {
    print(i)
}
```


## Using a for-loop

You can perform operations on the **loop variable**, in this case, called `i`

```{r}
for (i in 1:4) {
    print(i^2)
}
```


## Using a for-loop

- **Assignments** can occur in a loop
- The loop variable, `i`,  is not directly called in this loop
- The operation `x <- x^2` is done four times
- `x` changes each time because it is re-assigned in the loop

```{r}
x <- 2
for (i in 1:4) {
    x <- x^2
    print(x)
}
```


## Your turn {data-background-color=#b3cde3}

Create a for loop that ...

1. ...prints integers 1 to 100.

2. ...prints integers 100 to 1.

3. ...adds 1 to integers 1 through 5.

4. ...divides all even integers from 0 to 20 by 10. *Hint*: Use the `seq()` function.


## Vectors and for-loops

- In most of the above examples, we used the loop variable, `i`, directly in mathematical operations
- It is more common to use the loop variable to *loop over elements* of a vector (or matrix, or data frame)

```{r}
name.vec <- c("Larry", "Curly", "Moe")
for (i in 1:length(name.vec)) {
    print(paste("Hi,", name.vec[i], sep = " "))
}
```


## Vectors and for-loops

What did that really do? Consider the loop in pieces, here just for `i = 1`

```{r}
# the 1st position in name.vec
name.vec[1]
# combine text and indexed vector
paste("Hi,", name.vec[1], sep = " ") 
```


## For-loop output

- R suppresses printing inside for-loops (and other control flow structures)
- You can use the `print()` function to view the output of each iteration in your console

```{r}
name.vec <- c("Larry", "Curly", "Moe")
for (i in 1:length(name.vec)) {
    print(paste("Hi,", name.vec[i], sep = " "))
}
```


## For-loop output

Without `print()` or an assignment `<-`, no output is returned

```{r}
for (i in 1:length(name.vec)) {
    paste("Hi,", name.vec[i], sep = " ")
}
```


## Your turn {data-background-color=#b3cde3}

1. Create a vector of the days of the week and generate a message that says "Today is x" using a loop

2. Explain why the following code is wrong:

```{r, eval = FALSE}
for (x in 1:10) {
    print(sum(i))
}
```


## Data structure 5: Lists 

- **Lists** are the final basic data structure in R
- Lists, like vectors, are one-dimensional
- In the example with vector `x` below, `1` and `2` are converted to characters because `"blue"` is included -- elements in a vector must all be the same type

```{r}
x <- c(1, 2, "blue")
x
typeof(x)
```


## Lists can include multiple types

- In contrast, the elements of a list can be any type
- Lists may seem multidimensional, but they behave as one-dimensional data structures

```{r}
plant.lst <- list(Mass = seq(0, 0.25, 0.01), Count = 10:20, 
                  Adult = c(TRUE, FALSE, FALSE), 
                  Flower = c("open", "closed", "closed", "open"))
str(plant.lst)
```


## Constructing lists

You can construct a list using the `list()` function

```{r}
x <- c(1, 2, 3, 4, 5)
y <- c(3, 6, 8, 10)
test.vec <- c(x, y)  # create a vector
str(test.vec)
test.lst <- list(x, y)  # create a list
str(test.lst)
```


## List indexing

- Single square brackets `[]` return a list
- Double square brackets `[[]]` return list contents
- Main difference is the **class** of the output

```{r}
test.lst <- list(1:4, c(3.25, 6.75, 8.175, 4.5), 
                 c("apples", "bananas", "oranges", "pears"))
str(test.lst[2])  # returns a list
str(test.lst[[2]])  # returns numbers from list
```


## List indexing

The class of the output matters

```{r error = TRUE}
test.lst[1] * test.lst[2]  # can't do arithmetic on lists
test.lst[[1]] * test.lst[[2]]  # can do arithmetic on numbers
```


## List indexing

In order to reference a **single list element** directly, we have to use both the double square bracket `[[]]` operator and the single bracket `[]` operator

```{r}
test.lst[[2]]  # 2nd element of list 
test.lst[[2]][2]  # 2nd element of 2nd element of list 
```


## How do we save for-loop outputs?

- Instead of printing to the screen, we usually want to create a new object to store the for-loop output
- To do this, you need to create an empty vector or list before the loop

```{r}
output.vec <- c()  # create an empty vector
x <- rnorm(n = 10, mean = 1, sd = 0.5)
for (i in 1:length(x)) {
    output.vec[i] <- x[i] * 10
}
output.vec
```


## How do we save for-loop outputs?

- If you know ahead of time, you can make an empty vector with the size and the type of the output you want to store
- This makes computation faster!

```{r}
output.vec <- vector(mode = "numeric", length = 10)
x <- rnorm(n = 10, mean = 1, sd = 0.5)
for (i in 1:length(x)) {
    output.vec[i] <- x[i] * 10
}
output.vec
```


## Your turn {data-background-color=#b3cde3}

First, create a vector, `y`, with 10 random samples from a standard normal distribution `(mean = 0, sd = 1)`.

1. Compute `y[i] * 2` for 10 iterations (the length of vector y) using a for-loop with index `i`. Place the output in a **vector**.

2. Compute `y[i] * 2` for 10 iterations using a for-loop. Place the output in a **list**.

3. Find the the 4th element in the output vector from question 1 and the output list from question 2.


## Control flow statements - if

```{r}
if (3 > 2) {
    print("This makes sense")
}
if (3 < 2) {
    print("The world is not how I envisioned")
}
```


## Control flow statements - if

To have for-loops do different things under different conditions, use an `if` statement

```{r}
x <- 1:6
for (i in 1:length(x)) {
    if (x[i] > 3) {
        print(paste(x[i],"is greater than 3"))
    }
    if (x[i] <= 3) {
        print(paste(x[i],"is less than or equal to 3"))
    }
}
```


## Control flow statements - if else

- `if` and `else`: run one set of statements in one condition (`if`) and another set for every other possible condition (`else`)

```{r}
x <- rpois(n = 10, lambda = 1)
output.vec <- vector(mode = "numeric", length = 10)
for (i in 1:length(x)) {
    if (x[i] == 0) {
        output.vec[i] <- -100
    } else {
        output.vec[i] <- x[i]^2
    }
}
output.vec
```


## Control flow statements - break

We can end the for-loop if certain logical conditions are met using an `if` and a `break` statement

```{r}
x <- 1:8
for (i in 1:length(x)) {
    if (x[i] <= 3) {
        print(paste(x[i],"is less than or equal to 3"))
    } else if (x[i] > 3){
        break
    }
}
```


## Control flow statements - next

We can **skip** an element that we know will cause an error using an `if` and a `next` statement

```{r}
x <- -3:3
for (i in 1:length(x)) {
    if (x[i] <= 0) {
        next
    } else if (x[i] > 0) {
        print(log(x[i]))
    }
}
```


## Your turn {data-background-color=#b3cde3}

First, create a vector, `x`, with all integers from 1 to 100. Then, create a for-loop that...

1. ...computes `x[i] * 2` for 100 iterations (the length of vector `x`). Place the output in a vector. However, calculate `x[i] * 3` when `x[i] == 32`. 

2. ...computes `x[i] * 2` for 100 iterations. Place the output in a list. However, break the loop after 51 iterations.

3. ...computes `x[i] * 2` for 100 iterations. Place the output in a vector. However, skip `x == 71`.


## Alternatives to for-loops: `apply` family

- The `apply` family of functions allows you to repeatedly call a function across rows, columns, or elements
- The `apply(X, MARGIN, FUN)` function takes three arguments
    - `X`: is your matrix or data frame
    - `MARGIN = 1`: apply to rows
    - `MARGIN = 2`:  columns
    - `MARGIN = c(1, 2)`: rows and columns
    - `FUN`: function to apply


## Using `apply`

Use `apply()` to take the median of the columns of matrix `M` using the `median()` function

```{r}
M <- matrix(rnorm(9), ncol = 3, nrow = 3)
M
apply(M, 2, median)
```


## `apply` vs. for-loop

The same analysis, but using a for-loop

```{r}
median.vec <- c()
for (i in 1:ncol(M)) {
    median.vec[i] <- median(M[, i])
}
median.vec
```


## `apply` family of functions

- There are other versions of `apply()` for other data types:
  - `lapply()`: apply function to list or vector, return list
  - `sapply()`: apply function to list or vector, return list or vector if possible
  - `vapply()`: similar to `sapply()`, but you have to specify output type
  - `tapply()`: apply function split by factor
  - `mapply()`: apply function to multiple lists or vectors


## Using `lapply`

Use `lapply()` to apply a function to elements of a list

```{r, error = TRUE}
test.lst <- list(1:3, c(1.4, 4.6, 4.2, 2.1), rnorm(4))
sum(test.lst)  # returns an error 
lapply(test.lst, sum)
```


## Useful links

<a href = "https://adv-r.hadley.nz/subsetting.html" target = "_blank">Subsetting tutorial</a>

<a href = "https://adv-r.hadley.nz/control-flow.html" target = "_blank">Control flow</a>

<a href = "https://bookdown.org/content/d1e53ac9-28ce-472f-bc2c-f499f18264a3/loops.html" target = "_blank">For loops</a>

<a href = "https://www.r-bloggers.com/2022/03/complete-tutorial-on-using-apply-functions-in-r/" target = "_blank">Apply family of functions</a>

<a href = "http://www.r-bloggers.com/using-apply-sapply-lapply-in-r/" target = "_blank">Apply family of functions</a>


## Practice {data-background-color=#fbb4ae}

<a href = "https://rpubs.com/mccannecology/53355" target = "_blank">Worksheet</a>

<a href = "https://rpubs.com/mccannecology/53361" target = "_blank">Answers</a>


# **Part 5:** Functions


## Functions in R

- Functions contain sets of instructions that we want to carry out repeatedly
- We have already seen many of the basic functions that come pre-installed with R

```{r, eval = FALSE}
sum(seq(1, 100, 1))
abs(-100 + 50)
dim(iris)
str(iris)
mean(log10(iris$Sepal.Length))
```


## Functions in packages 

- We have also seen functions that are loaded from packages

```{r, eval = FALSE}
# this would not run - tree is not loaded 
tree(formula = Species ~ . -Species, data = iris) 
install.packages("tree")  # install package 
library(tree)  # load package 
# now it would work 
tree(formula = Species ~ . -Species, data = iris)
```


## Writing your own function

- *Define your own function* instead of writing the same lines of code over and over
- R functions are **objects** just like vectors, lists, etc.

`FunctionName <- function(<arguments>) { <body> }`


## Writing your own function

```{r}
# define function
SumTwoValues <- function(x, y) {
    return(x + y)
}
# call function
SumTwoValues(x = 1, y = 3) 
```


## Function environments

- Objects defined *inside* functions exist in a different **environment** than the global environment
    - Objects inside the function don't exist outside of the function!
- However, if a variable is not defined inside a function, the function will look one level above


## Function environments

If you run the function below, you'll see that `y` does not pop up in your Environment panel (top right)

```{r}
x <- 2  # x variable defined outside the function
HiddenY <- function() {
    y <- 1  # y variable defined inside the function 
    return(c(x, y))
}
# function looks for x one level above (in global environment)
HiddenY()
```


## Function output

Unless you explicitly return the output, you won't be able to access it

```{r}
NoReturn <- function(a, b) {
  # x, y, z exist only in function environment
    x <- a + b 
    y <- (a + b)^2
    z <- a / b
}
NoReturn(1, 2)  # doesn't return anything
YesReturn <- function(a, b) {
    x <- a + b 
    y <- (a + b)^2
    z <- a / b
    return(c(x, y, z))
}
YesReturn(1, 2)  # returns x, y, and z
```

## Function output

You can omit the `return()` function if you want

```{r}
YesReturn <- function(a, b) {
    x <- a + b 
    y <- (a + b)^2
    z <- a / b
    c(x, y, z)
}
YesReturn(1, 2)
```


## Your turn {data-background-color=#b3cde3}

Create a function that...

1. ...takes in two arguments, `x` and `y`, and computes `x * y * 2`.

2. ...takes in three arguments, and makes a vector from the result.

3. ...counts the number of matching elements in two separate vectors. *Hint:* use `%in%` to create a logical statement.


## Function arguments

Arguments can be passed to a function as a vector or a list

```{r}
params <- c(5, 25)
MultAlphaBeta <- function(p) {
    alpha <- p[1]
    beta <- p[2]
    return(alpha * beta)
}
MultAlphaBeta(params)
```


## Function default values

You can set pre-defined "default" values for function arguments

```{r}
subtract <- function(a = 5, b = 2) {
    return(a - b)
}
subtract()
subtract(3, 6)
```


## Your turn {data-background-color=#b3cde3}

Write a function that...

1. ...takes a vector as an argument and multiplies the sum of the vector by 10. Return a logical statement based on whether the sum is under 1000.

2. ...calculates the mean of every column in a data frame. Code the function so that it does not evaluate the column mean if the column elements are not numbers, using the logical statement **`class(x) != "numeric"`**. Try your function on the `iris` dataset.


## Your turn {data-background-color=#b3cde3}

```{r}
ColumnMeans <- function(x) {
  output <- c()
  for (i in 1:ncol(x)) {
    if(class(x[, i]) != "numeric") {
      output[i] <- NA
    }
    if(class(x[, i]) == "numeric") {
      output[i] <- mean(x[, i])
    }
  }
  names(output) <- colnames(x)
  return(output)
}
ColumnMeans(iris)
```


## Useful links

<a href = "https://dept.stat.lsa.umich.edu/~jerrick/courses/stat506_f24/01-R-basics.html#functions" target = "_blank">Tutorial on using functions in R</a>

<a href = "http://adv-r.had.co.nz/Functions.html" target = "_blank">Advanced R - Functions</a>


## Practice {data-background-color=#fbb4ae}

<a href = "https://rpubs.com/mccannecology/53356" target = "_blank">Worksheet</a>

<a href = "https://rpubs.com/mccannecology/53362" target = "_blank">Answers</a>


# **Part 6:** Data visualization using `ggplot2`


## Review {data-background-color=#decbe4}

`ggplot2` is not a base package, so we need to install it.

1. How would you install the package `ggplot2`?
2. What is the next step you need to do before you can use a function from `ggplot2`?


## Install and load `ggplot2`

```{r, eval = FALSE}
install.packages("ggplot2")
library(ggplot2)
```


## Why `ggplot2`?

- Works very well with data frames, especially when some of your data are factors
- Easier to create visually appealing figures 
- Useful for exploring trends in your data


## Why gg?

- `gg` stands for "grammar of graphics"
- There is a set of terms that defines the basic components of (every) plot
- Using this set of terms, you can produce figures using coherent, consistent syntax (very similar code for very different figures)
  - However, this syntax does vary quite a bit from typical R syntax!
  - If you are a little confused by the syntax at first, that probably just means that you are getting more comfortable with the R language


## The grammar

- A basic `ggplot` consists of:
  - `data`: Must be a **data frame**
  - `aes`(thetics): How your data are represented visually *(x, y, color, size, shape, etc.)*
  - `geom`(etry): What type of geometric objects you want to display *(points, lines, polygons, etc.)*


## A basic plot 

```{r, fig.height = 4, fig.width = 4}
library(ggplot2)
ggplot(data = iris, aes(x = Sepal.Length, y = Sepal.Width)) +
    geom_point()
```


## Plots can be assembled in pieces 

```{r, fig.height = 3, fig.width = 4}
# US state data from 1977
state.df <- data.frame(state.x77, state.region, state.abb)
state.fig <- ggplot(data = state.df, aes(x = Population, y = Area))
state.fig + geom_point()
```


## Aesthetics - point size

Increase the size of points using the `size` argument in `geom_point()`

```{r, fig.height = 3, fig.width = 4}
ggplot(data = state.df, aes(x = Population, y = Area)) + geom_point(size = 3)
```


## Aesthetics - color

Differentiate state region by **color** using the `color` argument in `aes()`

```{r, fig.height = 3, fig.width = 6}
ggplot(data = state.df, aes(x = Illiteracy, y = Murder, color = state.region)) + 
    geom_point(size = 2)
```


## Aesthetics - shape

Differentiate state region by **shape** using the `shape` argument in `aes()`

```{r, fig.height = 3, fig.width = 6}
ggplot(data = state.df, aes(x = Life.Exp, y = HS.Grad, color = state.region, shape = state.region)) + 
    geom_point(size = 2)
```


## Your turn {data-background-color=#b3cde3}

First, take a sample of 1000 rows from the `diamonds` dataset (pre-installed with R). Then, try to generate this plot using `ggplot()`.

```{r}
d2 <- diamonds[sample(1:nrow(diamonds), 1000), ]
```

```{r, fig.height = 3, fig.width = 6, echo = FALSE}
ggplot(data = d2, aes(x = carat, y = price, color = color)) + geom_point()
```


## Geoms

- Geoms are geometries that represent data points
    - We've already seen `geom_point()`
- You can see all options by typing `geom_` and hitting the tab key (`↹`)
    - Use `?geom_` to view the help page


## Geoms - Boxplot

```{r, fig.height = 4, fig.width = 4}
ggplot(iris, aes(x = Species,y = Sepal.Length)) + geom_boxplot()
```


## Geoms - Histograms

You can change the aesthetics, like `binwidth` or `fill`

```{r, fig.height = 3, fig.width = 5}
ggplot(faithful, aes(x = waiting)) + 
    geom_histogram(binwidth = 8, color = "black", fill = "paleturquoise")
```


## Geoms - Bar plots 

```{r, fig.height = 4, fig.width = 4}
ggplot(iris, aes(x = Species, y = Sepal.Length)) + 
    geom_bar(stat = "identity", fill = "firebrick1")
```


## Geoms - Line plots 

```{r, fig.height = 4, fig.width = 5.5}
mtcars$cyl <- as.factor(mtcars$cyl)
ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) + 
    geom_line()
```


## Geoms - Density plots 

```{r, fig.height = 4, fig.width = 5}
ggplot(faithful, aes(waiting)) + geom_density(fill = "thistle")
```


## Your turn {data-background-color=#b3cde3}

1. Make a histogram of `Sepal.Length` from the `iris` data set. What did `ggplot2` do with the different species?


## Facets

- **Facets** divide plots into subplots based on a factor
- Syntax is `facet_grid(. ~ Species)`, where columns are species and there is only one row

```{r, fig.height = 2.5, fig.width = 6, message = FALSE}
ggplot(iris, aes(Sepal.Length)) + geom_histogram(fill = "royalblue1") + 
    facet_grid(. ~ Species)
```


## Facets

```{r, fig.height = 4.5, fig.width = 3, message = FALSE}
ggplot(iris, aes(Sepal.Length)) + geom_histogram(fill = "royalblue1") + 
    facet_grid(Species ~ .)
```


## Stats

- Stats show summaries of your data by building a new variable to plot
- Type `stat_` and hit the tab key (`↹`) to see all options
    - Use `?stat_` to see the help screen


## Stats - smooth

Use `stat_smooth` to add a linear fit to a scatterplot

```{r, message = FALSE, fig.height = 3, fig.width = 6}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
    geom_point() + stat_smooth(method = "lm")
```


## Scales

- Scales map data values to aesthetics
- You can define colors, labels, limits, etc. for your scale
- Scales can modify axis (`scale_y_`, `scale_x_`), color (`scale_color_`), fill (`scale_fill_`), shape (`scale_shape_`), and size (`scale_size_`) aesthetics
    - `scale_*_continuous()`: continuous data
    - `scale_*_discrete()`: discrete data
    - `scale_*_manual()`: discrete data, you specify
    - `scale_*_log10()`: log transform an x- and/or y-axis 
    

## Scales - log scale

Include log x and log y axes using `scale_x_log10()` and `scale_y_log10()`

```{r, fig.height = 3, fig.width = 6}
ggplot(data = state.df, aes(x = Population, y = Area, color = state.region)) + 
    geom_point() + scale_y_log10() + scale_x_log10()
```


## Scales - manual

Choose colors manually using `scale_color_manual()`

```{r, fig.height = 3, fig.width = 6}
ggplot(data = state.df, aes(x = Population, y = Area, color = state.region)) + 
    geom_point() + scale_y_log10() + scale_x_log10() + 
    scale_color_manual(values = c(`South` = "palegreen3", `Northeast` = "palevioletred3", `West` = "peachpuff3", `North Central` = "paleturquoise3"), name = "Region")
```


## Axis labels

Edit labels, including x- and y-axis labels, using `labs()`

```{r, fig.height = 3, fig.width = 6}
ggplot(data = state.df, aes(x = Life.Exp, y = HS.Grad, color = state.region, shape = state.region)) +
    geom_point(size = 2) + 
    labs(x = "Life expectancy (years)", y = "High school graduation (%)")
```


## Labels inside figure

Add labels inside the figure using `geom_text()`

```{r, fig.height = 3, fig.width = 6}
ggplot(data = state.df, aes(x = Life.Exp, y = HS.Grad, color = state.region, shape = state.region)) +
    geom_text(aes(label = state.abb), size = 4) +
    labs(x = "Life expectancy (years)", y = "High school graduation (%)")
```


## Themes 

- Use **themes** to control the aesthetics of the figure
- You can make broad changes by including `theme_bw()` or `theme_classic()` (white backgrounds with/without gridlines, respectively)
- You can customize the theme by adding arguments to the `theme()` function (see `?theme` for all customization options)


## Themes 

```{r, fig.height = 4, fig.width = 6}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
    geom_point() + theme_classic() +
    theme(text = element_text(family = "Serif", size = 14))
```

## Themes 

```{r, fig.height = 4, fig.width = 6}
ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) + 
    geom_point() + theme_bw() +
    theme(axis.line = element_line(color = "deeppink"))
```


## Saving plots

- Plots created with `ggplot2` can be saved using the `ggsave()` function
- File type is determined by the file extension
- Specify the dimensions (`height`, `width`) and resolution (`dpi`)

```{r, eval = FALSE}
iris.fig <- ggplot(iris, aes(Species, Sepal.Length)) + 
    geom_bar(stat = "identity") + theme_bw()
ggsave(filename = "IrisSepalLength.png", iris.fig, dpi = 600,
       height = 4, width = 4, units = "in")
```


## R Tip: ggplot2 uses data frames {data-background-color=#ccebc5}

```{r,  fig.height = 3, fig.width = 4}
xvar <- rnorm(100)
yvar <- rnorm(100)
df <- data.frame(xvar, yvar)  # coerce to data frame 
ggplot(df, aes(xvar, yvar)) + geom_point()
```


## Wide format data

Sometimes data is in a **wide** format, with multiple observations in each row

```{r, echo = FALSE}
spp.df.wide <- data.frame(SpeciesA = rnorm(100, 50, 1), SpeciesB = rnorm(100, 75, 5), 
                          SpeciesC = rnorm(100, 20, 0.5), SpeciesD = rnorm(100, 25, 0.75))
```

```{r}
spp.df.wide[1:3, ]
dim(spp.df.wide)
```


## Proper data format - long

Data is much easier to analyze if it is in a **long** format, with only one row per observation (experimental unit)

```{r, echo = FALSE}
spp.df.long <- data.frame(Species = rep(c("A", "B", "C", "D"), 100), Mass = rnorm(400, 75, 5))
```

```{r}
spp.df.long[1:3, ]
dim(spp.df.long)
```


## Melting: from wide to long 

```{r}
# make some fake wide-format data
test.df.wide <- data.frame(A = rnorm(100, 50, 6),
                           B = rnorm(100, 75, 5), 
                           C = rnorm(100, 50, 4),
                           D = rnorm(100, 55, 3))
head(test.df.wide)
```


## Melting: from wide to long 

Use the `melt()` function from the `reshape2` package

```{r, message = FALSE}
library(reshape2)
test.df.long <- melt(data = test.df.wide,
                     variable.name = "Species",
                     value.name = "Mass")
head(test.df.long)
```


## Melting: from wide to long 

Melting the data makes it easier to plot with `ggplot2`

```{r, fig.height = 3, fig.width = 7, comment = FALSE}
ggplot(test.df.long, aes(x = Mass)) + 
    facet_grid(. ~ Species) + 
    geom_histogram(bins = 20, fill = "lightsalmon1")
```


## Useful links

<a href = "https://ggplot2.tidyverse.org/" target = "_blank">ggplot2 documentation</a>

<a href = "https://rstudio.github.io/cheatsheets/html/data-visualization.html" target = "_blank">ggplot Cheat Sheet</a>

<a href = "http://colorbrewer2.org" target = "_blank">R ColorBrewer</a>

<a href = "http://rpubs.com/mccannecology/47829" target = "_blank">Plotting means and error bars</a>

<a href = "http://www.cookbook-r.com/Graphs/" target = "_blank">R Cookbook: Graphs</a>


## Practice {data-background-color=#fbb4ae}

<a href = "https://rpubs.com/mccannecology/53357" target = "_blank">Worksheet</a>

<a href = "https://rpubs.com/mccannecology/53363" target = "_blank">Answers</a>


## Additional topics and links

- Using RMarkdown to document code in a more reproducible way:

<a href = "https://bookdown.org/yihui/rmarkdown-cookbook/" target = "_blank">RMarkdown cookbook</a>

<a href = "https://rmarkdown.rstudio.com/lesson-15.HTML" target = "_blank">RMarkdown cheatsheet</a>

- Combining, or merging, multiple datasets ("data wrangling"):

<a href = "https://thomasadventure.blog/posts/r-merging-datasets/" target = "_blank">Merging (Joining) datasets in R</a>

<a href = "https://r4ds.hadley.nz/joins.html" target = "_blank">Joins using tidyverse</a>


## Github

Last, you may want to create a GitHub account (where I've uploaded this course). GitHub is used for making code freely available as well as for version control (important for collaborating on projects):

<a href = "http://www.github.com" target = "_blank">GitHub</a>

<a href = "http://jonlefcheck.net/2013/11/04/a-basic-tutorial-to-version-control-using-git/" target = "_blank">Basic tutorial on using GitHub (with RStudio)</a>

<a href = "https://docs.github.com/en/get-started/start-your-journey/about-github-and-git" target = "_blank">GitHub tutorial</a>
